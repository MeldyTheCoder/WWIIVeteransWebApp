import typing
import settings
import operator
import sqlalchemy
from sqlalchemy.schema import CreateColumn
from sqlalchemy.ext.compiler import compiles
from datetime import datetime
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy_utils import database_exists, create_database, drop_database

DATABASE_CONNECTION_URL = settings.DATABASE_URL

drop_database(DATABASE_CONNECTION_URL)
if not database_exists(DATABASE_CONNECTION_URL):
    create_database(DATABASE_CONNECTION_URL)

engine = sqlalchemy.create_engine(DATABASE_CONNECTION_URL)
session = sqlalchemy.orm.Session(bind=engine)

FILTER_QUERIES = {
    'in': operator.contains,
    'contains': operator.contains,
    'eq': operator.eq,
    'gt': operator.gt,
    'gte': operator.ge,
    'lte': operator.le,
    'lt': operator.lt,
    'is_not': operator.is_not,
    'and': operator.and_,
    'or': operator.or_,
    'index': operator.indexOf,
}


@compiles(CreateColumn, 'postgresql')
def use_identity(element, compiler, **kw):
    text = compiler.visit_create_column(element, **kw)
    text = text.replace("SERIAL", "INT GENERATED BY DEFAULT AS IDENTITY")
    return text


def get_current_time():
    return datetime.now()


class SqlAlchemyModel(DeclarativeBase):
    """
    Базовая модель СУБД проекта
    """

    id = sqlalchemy.Column(
        sqlalchemy.BigInteger(),
        sqlalchemy.Identity(start=1, cycle=False),
        primary_key=True
    )

    def __str__(self):
        return f'<{self.__class__.__name__}: {self.as_dict()}>'

    def __repr__(self):
        return self.__str__()

    def as_dict(self):
        instance_dict = self.__dict__.copy()
        instance_dict.pop('_sa_instance_state')

        return instance_dict

    @classmethod
    def filter_field(cls, key, value):
        default_filter_name = 'eq'

        if key.count('__') > 1:
            raise RuntimeError(
                'Указано больше параметров, чем нужно'
            )

        if '__' not in key:
            filter_name = default_filter_name
        else:
            filter_input = key.split('__')
            filter_name = filter_input[-1]
            key = filter_input[0]

        if filter_name not in FILTER_QUERIES:
            raise RuntimeError(
                f'Фильтра "__{filter_name}" не существует.'
            )

        filter_func = FILTER_QUERIES[filter_name]
        return filter_func(getattr(cls, key), value)

    @classmethod
    def convert_kwargs(cls, **kwargs):
        new_filters = []

        for key, value in kwargs.items():
            new_filters.append(
                cls.filter_field(key, value)
            )

        return new_filters

    @classmethod
    def fetch_one(cls, *filters: typing.Callable, **kwargs: [str, typing.Any]):
        kwargs_filters = cls.convert_kwargs(**kwargs)

        query = session.execute(
            sqlalchemy.select(cls).where(*filters, *kwargs_filters).limit(1)
        )

        response = query.fetchone()
        if not response:
            return None

        return response[0]

    @classmethod
    def fetch_all(cls, *filters: typing.Callable, **kwargs: [str, typing.Any]):
        kwargs_filters = cls.convert_kwargs(**kwargs)

        query = session.execute(
            sqlalchemy.select(cls).where(*filters, *kwargs_filters)
        )

        result = query.fetchall()
        return [row[0] for row in result]

    @classmethod
    def create(cls, **kwargs):
        if 'id' in kwargs:
            kwargs.pop('id')

        query = session.execute(
            sqlalchemy.insert(cls).values(**kwargs)
        )

        session.commit()
        return cls.fetch_one(id=query.lastrowid + 1)

    @classmethod
    def delete(cls,  *filters: typing.Callable, **kwargs: [str, typing.Any]):
        kwargs_filters = cls.convert_kwargs(**kwargs)

        session.execute(
            sqlalchemy.delete(cls).where(*filters, *kwargs_filters)
        )

        return session.commit()

    @classmethod
    def update(cls, row_id: int, **kwargs):
        filter_query = cls.convert_kwargs(id=row_id)

        query = session.execute(
            sqlalchemy.update(cls).where(*filter_query).values(**kwargs)
        )

        session.commit()
        return cls.fetch_one(id=query.lastrowid)


class Veteran(SqlAlchemyModel):
    """
    Модель ветерана БД
    """

    __tablename__ = 'veterans'

    first_name = sqlalchemy.Column(
        sqlalchemy.VARCHAR(length=100),
        nullable=False,
        name='firstName'
    )

    last_name = sqlalchemy.Column(
        sqlalchemy.VARCHAR(length=100),
        nullable=False,
        name='lastName'
    )

    surname = sqlalchemy.Column(
        sqlalchemy.VARCHAR(length=100),
        nullable=True,
        name='surname'
    )

    description = sqlalchemy.Column(
        sqlalchemy.VARCHAR(length=512),
        nullable=False,
        name='description'
    )

    quote = sqlalchemy.Column(
        sqlalchemy.VARCHAR(length=120),
        nullable=True,
        name='quote'
    )

    photo_url = sqlalchemy.Column(
        sqlalchemy.VARCHAR(length=1000),
        nullable=True,
        name='photoUrl'
    )

    years_of_battle = sqlalchemy.Column(
        sqlalchemy.ARRAY(sqlalchemy.Integer, as_tuple=True),
        nullable=False,
        name='yearsOfBattle'
    )

    date_of_birth = sqlalchemy.Column(
        sqlalchemy.Date(),
        nullable=False,
        name='dateOfBirth'
    )

    date_of_death = sqlalchemy.Column(
        sqlalchemy.Date(),
        nullable=True,
        name='dateOfDeath'
    )

    created_by = sqlalchemy.Column(
        sqlalchemy.ForeignKey(
            column='users.id',
            ondelete='CASCADE'
        ),
        nullable=True,
        name='createdBy'
    )


class User(SqlAlchemyModel):
    """
    Модель пользователя БД
    """

    __tablename__ = 'users'

    email = sqlalchemy.Column(
        sqlalchemy.VARCHAR(255),
        nullable=False,
        name='email'
    )

    password_hash = sqlalchemy.Column(
        sqlalchemy.VARCHAR(1000),
        nullable=False,
        name='passwordHash'
    )

    first_name = sqlalchemy.Column(
        sqlalchemy.VARCHAR(50),
        nullable=False,
        name='firstName'
    )

    last_name = sqlalchemy.Column(
        sqlalchemy.VARCHAR(50),
        nullable=True,
        name='lastName'
    )

    date_joined = sqlalchemy.Column(
        sqlalchemy.DateTime(),
        nullable=False,
        default=datetime.now,
        name='dateJoined'
    )

    date_password_changed = sqlalchemy.Column(
        sqlalchemy.DateTime(),
        nullable=True,
        default=datetime.now,
        name='datePasswordChanged'
    )

    email_verified = sqlalchemy.Column(
        sqlalchemy.Boolean(),
        nullable=False,
        default=False,
        name='emailVerified'
    )


SqlAlchemyModel.metadata.create_all(bind=engine)
